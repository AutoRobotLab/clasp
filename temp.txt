
stats: 
	- keep: ||
	
initMoms, scoreOther, berkHuang, berkOnce:
	- keep: ||

saveProgress, signFix, optHeuristic:
	- keep: |
	
domPref, domMod:
	- keep: |

noLookback: 
	- keep: ||

Option         | Transition    | Remark        |
---------------|---------------|---------------|
suppModels     | not supported |               |
eq             | ok            |               |
backprop       | ok            |               |
noGamma        | ok            |               |
eqDfs          | ok            |               |
transExt       | ok            |               |
---------------|---------------|---------------|
solveLimit     |               | per call?     |
parallelMode   | ok            |               |
globalRestarts | ok            | per call!     |
distMode       | ok            | per call!     |
distribute     | ok            | per call!     |
integrate      | ok            |               |
enumMode       | ok            |               |
optMode        | ok            |               |
optBound       | ok            |               |
optSat         | ok            | del on step   |
project        | ok            |               |
models         | ok            |               |
---------------|---------------|---------------|
stats          | on -> off     | fails         |
share          | ok            |               |
learnExplicit  | ok            |               |
satPrepro      | ok            |               |
---------------|---------------|---------------|
restartOnModel | ok            |               |
lookahead      | ok            |               |
heuristic      | ok            |               |
initMoms       | fail          | fixed in ctor |
scoreOther     | fail          | fixed in ctor |
signDef        | ok            |               |
signFix        | fail          | no unfix      |
berkHuang      |               | only in ctor  |
berkOnce       |               | only in ctor  |
nant           | ok            |               |
domPref        | ???           | fixed in ctor |
domMod         | ???           | fixed in ctor |
optHeuristic   | ???           | no unset for 1|
optStrategy    | ok            |               |
saveProgress   | ???           | no unsafe     |
initWatches    | ok            | only new      |
updateMode     | ok            |               |
seed           | ok            |               |
noLookback     | ???           | destructive   |
forgetOnStep   | ok            |               |
strengthen     | ok            |               |
otfs           | ok            |               |
updateLbd      | ok            |               |
updateAct      | ok            |               |
reverseArcs    | ok            |               |
contraction    | ok            |               |
loops          | ok            |               |
partialCheck   | ok            |               |
randFreq       | ok            |               |
randProb       | ok            |               |
restarts       | ok            |               |
resetRestarts  | ok            |               |
localRestarts  | ok            |               |
counterRestarts| ok            |               |
counterBump    | ok            |               |
shuffle        | ok            |               |
deletion       | ok            |               |
delGrow        | ok            |               |
delCfl         | ok            |               |
delInit        | ok            |               |
delEstimate    | ok            |               |
delMax         | ok            |               |
delOnRestart   | ok            |               |
---------------|---------------|---------------|

BUG: possible Mem-Leak!!!
	if (s.sharedContext()->sccGraph.get() == 0) { 
		s.removePost(this);
		return true; 
	}


// Macros for defining strong enums
#define CLASP_DECLARE_ENUM_MEMBER(__x, __y, __z, __d) __x __y,
#define CLASP_ENUM_MEMBER_MAKE_TUPLE(__x, __y, __z, __d) { __x, __z, __d },
#define CLASP_MAKE_STRONG_ENUM(name, ENUM_DESC) \
	struct name {\
		enum name##_t {    \
			ENUM_DESC(CLASP_DECLARE_ENUM_MEMBER) \
		};\
		struct EM { name##_t eVal; const char* eString; const char* eDesc; }; \
		typedef name##_t enum_type; \
		typedef const EM* iterator; \
		typedef std::pair<iterator, iterator> range_type; \
		static range_type range() { \
			static const EM vals[] = {\
			ENUM_DESC(CLASP_ENUM_MEMBER_MAKE_TUPLE)\
			{static_cast<name##_t>(-1),0,0}};\
			return range_type(vals, vals + ((sizeof(vals)/sizeof(EM))-1));\
		}\
		static iterator begin() { return range().first; }\
		static iterator end()   { return range().second;}\
	};\
	typedef name::enum_type name##_t



Init of Configuration:
======================
a) via special key "init" = "<cmd-line>"
   prg.conf.init = "--config=handy -t4"
   get("init") returns last set string or empty
b) via key "configuration" = "<cfgKey>"
   prg.conf.configuration = "handy"
   prg.conf.parallelMode  = 4
   
prog.conf.init = "handy"  // -> --config=handy
prog.conf.init = "foobar" // -> --config=foobar (i.e. file based)
prog.conf.init = "--config=handy -t4" // -> <cmd-line>
prog.conf.init = "[t1]: ...\n" // porfolio
prog.conf.solver.init = "frumpy"

get("init"):
	if (cliConfig <= max) return name of cliConfig
	else {
		return config_s[cliConfig - max];
	}
	
if (id == key_init)    {
	releaseConfig(active()->cliConfig);
	if (*val == '[') {
		k = makeConfig(*val);
		initActive(k, 0, false);
		return static_cast<int>(active()->hasConfig);
	}
	else if (*val == '-') {
		RawConfig x(*val);
		setAppConfig(x, Asp);
		store x in vector
	}
	else {
		setAppOpt(id, setVal);
		initActive(active()->cliConfig, 0);
		if (releaseConfig(active()->cliConfig) > max) {
			config[releaseConfig(active()->cliConfig)] = setVal
		}
	}
	
	
	if () { return 0; }
	initActive(active()->cliConfig, 0);
	if (releaseConfig(active()->cliConfig)) { active()->cliConfig = 0; }
	return static_cast<int>(active()->hasConfig);
}
	
set("init", val):
	
	if (*val != '-' && *val != '[') { setAppOpt; }
	else if (*val == '-') { makeConfig("<init>", *val) + allowConfig opt }
	else if (*val == '[') 



#define _SET(K, BODY) static bool __set_##K BODY
#define _GET(K, BODY) static std::string __get_##K BODY
#define SET(X, Y)     (void* X, const char* Y)
#define GET(X)        (void* X)
#define COMMA() ,
#define TLIST(x, ...) x , __VA_ARGS__

#define OPTION(n, k, S, G) \
	_SET(k, S) \
	_GET(k, G) 


OPTION(3, 4, \
	SET(cfg, VAL){        \
		printf("%s\n", VAL);\
		return true;        \
	},                    \
	GET(IN) {             \
		return static_cast<const char*>(IN); \
	})



uint32 KeyType:
 16 bit handle: 
 8  bit solver:
 6  bit mode;
 1  bit arr;    Key == solver &&
 1  bit isOpt; 
 
 
Loop:
startPath(s, disjoint);
bool more = true;
do { 
	if ((val = update(s)) == value_free) { // integrate new info/path
		val = solve();
	}
	if      (val == value_free) { break; }
	else if (val == value_true) { more = !commitModel() || reportModel(); }
	else if (val == value_false){ more = commitUnsat(); }
} while (more);


Loop:
startPath(s, disjoint);
do {
	while (update(s) && (solve() == value_true)) {
		onModel(s);
	}
} while (onUnsat(s));

Interface:
	- bool startPath(Solver& s, bool disjoint);
	- bool update(Solver& s);
	- bool onModel(Solver& s);
	- bool onUnsat(Solver& s);
	- void reset(enum Type = {full, switch-mode})
	
Data: 
	LitVec gp for storing path to restore
	
	
	
DefMin::startPath:
	- init/reset step
	- return update
	
DefMin::update:
	- integrate bounds

DefMin::onModel:
	- commit upper bound

DefMin::onUnsat:
	- reset local bound

DefMin::reset
	- reset bound
	- reset step
	

UncoreMin::startPath:
	- init level 0
	- init root
	
UncoreMin::update:
	- integrate next level
	- check shared bounds/sat

UncoreMin::onModel:
	- commit upper bound, set sat

UncoreMin::onUnsat:
	- commit lower bound
	- integrate cores

UncoreMin::reset
	- 
	- reset step


TODO
====

#define DEF_SOLVE    {opt_heuristic,"Berkmin"},{opt_restarts,"x,100,1.5"},{opt_deletion,"1,75"},{opt_del_init_r,"200,40000"},{opt_del_max,400000}, {opt_del_algo,"basic"}, {opt_contraction,"250"}, {opt_loops,"common"}, {opt_save_p,"180"}
#define FRUMPY_SOLVE DEF_SOLVE, {opt_del_grow,"1.1"},{opt_strengthen,"local"},{opt_disj_true,"1"}
#define JUMPY_SOLVE  {opt_heuristic,"Vsids"}, {opt_restarts,"L,100"}    , {opt_deletion,"3,75"}     , {opt_del_init_r,"1000,20000"}, {opt_del_algo,basic,"2"}           , {opt_del_grow,"1.1,25,x,100,1.5"}, {opt_del_cfl,"x,10000,1.1"}, {opt_del_glue,"2"}, {opt_update_lbd,"3"}        , {opt_strengthen,"recursive"}, {opt_otfs,"2"}            , {opt_save_p,"70"}
#define HANDY_SOLVE  {opt_heuristic,"Vsids"}, {opt_restarts,"D,100,0.7"}, {opt_deletion,"2,50,20.0"}, {opt_del_max,"200000"}       , {opt_del_algo,sort,"2"}            , {opt_del_init_r,"1000,14000"}    , {opt_del_cfl,"+,4000,600"} , {opt_del_glue,"2"}, {opt_update_lbd,"1"}        , {opt_strengthen,"recursive"}, {opt_otfs,"2"}            , {opt_save_p,"20"}     , {opt_contraction,"600"}, {opt_loops,"distinct"}, {opt_counter_restarts,"7"}, {opt_counter_bump,"1023"}, {opt_reverse_arcs,"2"}
#define CRAFTY_SOLVE {opt_heuristic,"Vsids"}, {opt_restarts,"x,128,1.5"}, {opt_deletion,"3,75,10.0"}, {opt_del_init_r,"1000,9000"} , {opt_del_grow,"1.1,20.0"}          , {opt_del_cfl,+,"10000,1000"}     , {opt_del_algo,"basic"}     , {opt_del_glue,"2"}, {opt_otfs,"2"}              , {opt_reverse_arcs,"1"}      , {opt_counter_restarts,"3"}, {opt_contraction,250"},
#define TRENDY_SOLVE {opt_heuristic,"Vsids"}, {opt_restarts,"D,100,0.7"}, {opt_deletion,"3,50"}     , {opt_del_init,"500,19500"}   , {opt_del_grow,"1.1,20.0,x,100,1.5"}, {opt_del_cfl,+,"10000,2000"}     , {opt_del_algo,"basic"}     , {opt_del_glue,"2"}, {opt_strengthen,"recursive"}, {opt_update_lbd,"1"}        , {opt_otfs,"2"}            , {opt_save_p,"75"}     , {opt_counter_restarts,"3"}, {opt_counter_bump,"1023"}, {opt_reverse_arcs,"2"},  {opt_contraction,"250"}, {opt_loops,"common"}
#define JUMPY_GLOBAL {opt_sat_prepro,"20,25,240,-1,1"}, {opt_trans_ext,"dynamic"}
#define HANDY_GLOBAL {opt_sat_prepro,"10,25,240,-1,1"}, {opt_trans_ext,"dynamic"}, {opt_backprop,"1"}


static OptArg* getDefaultConfig(DefaultConfig c) {
	switch(c) {
		default: return 0;
		case frumpy : { static OptArg x[] = {FRUMPY_SOLVE,{0,0}};              return x; }
		case jumpy  : { static OptArg x[] = {JUMPY_GLOBAL, JUMPY_SOLVE,{0,0}}; return x; }
		case handy  : { static OptArg x[] = {HANDY_GLOBAL, HANDY_SOLVE,{0,0}}; return x; }
		case crafty : { static OptArg x[] = {HANDY_GLOBAL,CRAFTY_SOLVE,{opt_save_progress,"180"},{0,0}}; return x; }
		case trendy : { static OptArg x[] = {JUMPY_GLOBAL,TRENDY_SOLVE,{0,0}}; return x; }
	}
}
Todo:
	- PrgAtomNode::simplifyBodies()
		- check for & remove duplicate disjunctions
	- PrgDisjunction::simplify()
		- remove unsupported bodies
		- replace eq bodies
		- remove false/eq atoms
		- drop if true atom
	- call dispose() on program?
	- temporarily add unfreeze atoms to atoms_?
	- backpropagate true atoms (not only weak_true)
	- maintain flag inSCC in body?
	
Open Issues:
	- merge preprocessSimple() with preprocessEq()?
	- handle disjunctions in simplifyClassifiedProgram()
	- handle disjunctions in atom support clause
	
Special Handling:
	- newFalseBody:       map To propagateFalse() ? 
	- classifyProgram:
	- preprocessSimple:
	- reinitDeps: 
	- simplifyBody
	- replace
	- propagateFalse
	- visitDfs
	- transformIntegrity
	- writeRule
	- removeHead
	

BODY
====
PrgBodyNode::reinitDeps(ProgramBuilder& prg, uint32 id);
PrgBodyNode::sortBody();
void PrgBodyNode::removeHead(ProgramBuilder& prg, Var headId, HeadEdge::Type t) {
	if (t != HeadEdge::DISJUNCTIVE_HEAD) {
		HeadList::left_iterator it, end;
		for (it = const_cast<HeadList::left_iterator>(heads_begin()), end = const_cast<HeadList::left_iterator>(heads_end()); it != end; ++it) {
			if (it->type() == t && it->node() == headId) {
				HeadList::left_iterator j;
				for (j = it++; it != end; ++it) { 
					if (it->type() != t || it->node() != headId) { 
						*j++ = *it; 
					} 
				}
				extHead() ? heads_.ext->shrink_left(j) : extHead_ = (j - heads_.simp);
				break;
			}
		}
	}
	else if (extHead()) {
		HeadList::right_iterator d = std::find(heads_.ext->right_begin(), heads_.ext->right_end(), headId);
		if (d != heads_.ext->right_end()) {
			// 1. remove disjunctive edge
			heads_.ext->erase_right(d);
			// 2. update flat list 
			// - mark all disjunctive heads
			RuleState& rs = prg.ruleState_;
			for (d = heads_.ext->right_begin(); d != heads_.ext->right_end(); ++d) {
				PrgDisjunction* dis = prg.disjunctions_[*d];
				if (!dis->ignore()) {
					for (PrgDisjunction::atom_iterator it = dis->begin(), end = dis->end(); it != end; ++it) {
						rs.addToHead(*it, HeadEdge::DISJUNCTIVE_HEAD);
					}
				}
			}
			// - remove those from flat list that are not marked
			HeadList::left_iterator j       = heads_.ext->left_begin();
			for (HeadList::left_iterator it = heads_.ext->left_begin(), end = heads_.ext->left_end(); it != end; ++it) {
				if (!it->disjunctive() || rs.inHead(it->node(), it->type())) {
					*j++ = *it;
					rs.popFromRule(it->node());
				}
			}
			heads_.ext->shrink_left(j);
		}		
	}
	if (!hasHeads() && value() != value_false) {
		setIgnore(true);
	}
}

DISJ
====
PrgDisj::supports() const;
PrgDisj::atomSupportLiteral() const;
PrgDisj::removeSupport(Var bodyId);
PrgDisj::propagateAssigned(ProgramBuilder& prg, Var atomId, ValueRep v);
PrgDisj::propagateValue(ProgramBuilder& prg);
PrgDisj::markDirty();

// NEW GRAPH
Node:
=====
	bool inProgram() const { return upper_ != 0; }
	bool eq()        const { return eq_ == 1 && id_ != MAX; }
	bool removed()   const { return eq_ == 1 && id_ == MAX; }
	uint32  id_   : 28;  // own id/eq-id/root-id/ufs-id
	uint32  val_  :  2;  // assigned value
	uint32  eq_   :  1;  // eq to some other node?
	uint32  seen_ :  1;  // marked as seen?
	uint32 lit_   : 31; // literal index in solver or FALSE
	uint32 upper_ :  1; // in upper closure, i.e. simplified program

Body is a Node
==============
	VarVec heads; // list of head ids

Head is a Node
==============
	RuleEdgeVec supports_;// possible supports (body+choice, body+normal, or disjunction)
	uint32 type   : 1     // atom or disjunction   
	uint32 noScc  : 1     // ignore during scc checks? 
	uint32 sBody_ : 1;    // simplify supports_?
	uint32 frozen_: 1;    // currently frozen, i.e. defined in a later incremental step?
Atom is a Head
==============
	uint32 scc_ : 28;     // SCC of this atom 
	LitVec deps_;         // bodies depending on this atom
Disjunction is a Head
=====================
	uint32 size_ : 28;    // number of atoms in disjunction
	Var    atoms_[0];
	


#if 0
/////////////////////////////////////////////////////////////////////////////////////////
// class PrgDisjunction
//
// Objects of this class represent disjunctive heads
/////////////////////////////////////////////////////////////////////////////////////////
// *this == other
bool PrgDisjunction::eq(const PrgDisjunction& other) const {
	return size() == other.size()
		&& std::equal(heads_, heads_+size(), other.heads_);
}

// removes the body from the set of bodies supporting this disjunction
bool PrgDisjunction::removeDef(ProgramBuilder& prg, uint32 myId, PrgBodyNode* b) {
	assert(prg.disjunctions_[myId] == this);
	for (VarVec::iterator it = defs_.begin(); it != defs_.end(); ++it) {
		if (prg.bodies_[*it] == b) {
			*it = defs_.back();
			defs_.pop_back();
			break;
		}
	}
	if (defs_.empty()) {
		remove(prg, myId);
		return true;
	}
	return false;
}

// removes the given atom from this disjunction
bool PrgDisjunction::removeAtom(Preprocessor& pre, Var atomId) {
	// remove the atom - but keep sorted!
	uint32* j  = heads_;
	for (uint32* it = heads_, *end = heads_+size_; it != end; ++it) {
		if (*it != atomId) {
			*j++ = *it;
		}
	}
	size_ = j - heads_;
	if (size_ == 1) {
		// no longer a disjunctive rule
		// replace with normal rule(s)
		setIgnore(true);
		ProgramBuilder& prg = *pre.program();
		Var last = *heads_;
		prg.atoms_[last]->removeDef(prg, this);
		size_ = 0;
		VarVec temp;
		temp.swap(defs_);
		for (VarVec::iterator it = temp.begin(); it != temp.end(); ++it) {
			PrgBodyNode* b = prg.bodies_[*it];
			b->addHead(prg, *it, last, HeadEdge::NORMAL_HEAD);
			b->simplifyHeads(pre, false);
		}
	}
	return size_ <= 1;
}

void PrgDisjunction::remove(ProgramBuilder& prg, Var myId) {
	setIgnore(true);
	for (atom_iterator it = begin(), end = this->end(); it != end; ++it) {
		PrgAtomNode* a = prg.atoms_[*it];
		a->removeDef(prg, this);
	}
	for (VarVec::const_iterator it = defs_.begin(); it != defs_.end(); ++it) {
		PrgBodyNode* b = prg.bodies_[*it];
		b->removeHead(prg, myId, HeadEdge::DISJUNCTIVE_HEAD);
	}
}

// returns true if atom is in this disjunction
bool PrgDisjunction::hasAtom(Var atomId) const {
	return std::binary_search(begin(), end(), atomId);
}
// adds edges between this disjunction and its head atoms
void PrgDisjunction::initDeps(ProgramBuilder& prg, uint32 myId) {
	for (atom_iterator it = begin(), end = this->end(); it != end; ++it) {
		prg.atoms_[*it]->addDef(myId, HeadEdge::DISJUNCTIVE_HEAD);
	}
}
// returns true if disjunction has at least one supported body
bool PrgDisjunction::isSupported(const ProgramBuilder& prg)  const {
	if (ignore()) return false;
	for (VarVec::const_iterator it = defs_.begin(); it != defs_.end(); ++it) {
		PrgBodyNode* b = prg.bodies_[*it];
		if (b->value() != value_false && (b->hasVar() || b->isSupported())) {
			return true;
		}
	}
	return false;
}

PROGRAM
=======
namespace {
	struct LessBody {
		bool operator()(PrgBodyNode* lhs, PrgBodyNode* rhs) const {
			if (lhs->type() == rhs->type()) {
				if (lhs->size() == rhs->size()) {
					if (lhs->posSize() == rhs->posSize()) {
						for (uint32 i = 0; i != lhs->size(); ++i) {
							if (lhs->goal(i) != rhs->goal(i)) {
								return lhs->goal(i) < rhs->goal(i);
							}
						}
						return false;
					}
					return lhs->posSize() < rhs->posSize();
				}
				return lhs->size() < rhs->size();
			}
			return lhs->type() < rhs->type();
		}
	};
}
void ProgramBuilder::normalize() {
	bodyIndex_.clear();
	initialSupp_.clear();
	for (VarVec::size_type i = 0; i != atoms_.size(); ++i) {
		atoms_[i]->clearDeps();
	}
	for (VarVec::size_type i = 0; i != bodies_.size(); ++i) {
		bodies_[i]->sortBody();
	}
	std::sort(bodies_.begin(), bodies_.end(), LessBody());
	for (VarVec::size_type i = 0; i != bodies_.size(); ++i) {
		uint32 id= uint32(i);
		uint32 h = bodies_[i]->reinitDeps(*this, id);
		bodyIndex_.insert(BodyIndex::value_type(h, id));
		if (bodies_[i]->isSupported()) {
			initialSupp_.push_back(id);
		}
	}	
	for (VarVec::size_type i = 0; i != disjunctions_.size(); ++i) {
		disjunctions_[i]->initDeps(*this, (uint32)i);
	}
}
